---
title: "[ë²ˆì—­] Reactì˜ useEffect()ëŠ” ì–´ë–»ê²Œ ë™ì‘í•˜ë‚˜ìš”?"
datePublished: Tue Apr 09 2024 03:46:58 GMT+0000 (Coordinated Universal Time)
cuid: clurubb2w000508k2cm1904k3
slug: react-internals-deep-dive-4
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1712560949630/0ed6696c-8e68-4f45-8d24-5f3c6d27a16c.jpeg
tags: react-internals

---

> ì˜ë¬¸ ë¸”ë¡œê·¸ ê¸€ì„ ë²ˆì—­í–ˆìŠµë‹ˆë‹¤. í—ˆê°€ë¥¼ ë°›ìœ¼ë©´ ì‹œë¦¬ì¦ˆë¥¼ ì´ì–´ê°ˆ ì˜ˆì •ì…ë‹ˆë‹¤.  
> ì›ë¬¸ë§í¬: [https://jser.dev/2023-07-08-how-does-useeffect-work](https://jser.dev/2023-07-08-how-does-useeffect-work)

---

> â„¹ï¸ [React Internals Deep Dive](https://jser.dev/series/react-source-code-walkthrough.html) ì—í”¼ì†Œë“œ 4, [ìœ íŠœë¸Œì—ì„œ ì œê°€ ì„¤ëª…í•˜ëŠ” ê²ƒ](https://www.youtube.com/watch?v=Ggmdo7TORNc&list=PLvx8w9g4qv_p-OS-XdbB3Ux_6DMXhAJC3&index=4)ì„ ì‹œì²­í•´ì£¼ì„¸ìš”.
> 
> âš  [React@18.2.0](https://github.com/facebook/react/releases/tag/v18.2.0) ê¸°ì¤€, ìµœì‹  ë²„ì „ì—ì„œëŠ” êµ¬í˜„ì´ ë³€ê²½ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

`useEffect()`ëŠ” Reactì—ì„œ `useState()`ë¥¼ ì œì™¸í•˜ê³  ê°€ì¥ ë§ì´ ì‚¬ìš©ë˜ëŠ” í›…ì…ë‹ˆë‹¤.  
ë§¤ìš° ê°•ë ¥í•˜ì§€ë§Œ ë•Œë•Œë¡œ í˜¼ë€ìŠ¤ëŸ¬ìš¸ ìˆ˜ ìˆëŠ”ë°, ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ ì•Œì•„ë´…ì‹œë‹¤.

```jsx
useEffect(() => {
  // ...
}, [deps])
```

- [1. ìµœì´ˆ ë§ˆìš´íŠ¸ì—ì„œ `useEffect()`](#heading-1-useeffect)
- [2. ë¦¬-ë Œë”ë§ì˜ `useEffect()`](#heading-2-useeffect)
- [3. EffectëŠ” ì–¸ì œ, ì–´ë–»ê²Œ ì‹¤í–‰ë˜ê³  ì •ë¦¬ë˜ë‚˜ìš”?](#heading-3-effect)
  - [3.1 íŒ¨ì‹œë¸Œ Effectì— ëŒ€í•œ flushingì€ `commitRoot()`ë‚´ì—ì„œ íŠ¸ë¦¬ê±° ë©ë‹ˆë‹¤.](#heading-31-effect-flushing-commitroot)
  - [3.2 `flushPassiveEffects()`](#heading-32-flushpassiveeffects)
  - [3.3 `commitPassiveUnmountEffects()`](#heading-33-commitpassiveunmounteffects)
  - [3.4 `commitPassiveMountEffects()`](#heading-34-commitpassivemounteffects)
- [4. ìš”ì•½](#heading-4)
- [5. í€´ì¦ˆ ì±Œë¦°ì§€](#heading-5)

## 1\. ìµœì´ˆ ë§ˆìš´íŠ¸ì—ì„œ `useEffect()`

`useEffect()`ëŠ” ìµœì´ˆ ë§ˆìš´íŠ¸ì—ì„œ `mountEffect()`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

> ***ğŸ’¬ ì—­ì ì£¼ì„: Jserì˜ ì½”ë©˜íŠ¸ëŠ” â—â—ë¡œ í‘œì‹œ í•´ë’€ìŠµë‹ˆë‹¤.  
> ê·¸ ì™¸ ì£¼ì„ì€ ë¦¬ì•¡íŠ¸ ì†ŒìŠ¤ ì½”ë“œ ìì²´ì˜ ì£¼ì„ì…ë‹ˆë‹¤.  
> ... ì€ ìƒëµëœ ì½”ë“œì…ë‹ˆë‹¤.***
```typescript
function mountEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null,
): void {
  return mountEffectImpl(
    PassiveEffect | PassiveStaticEffect,
    // â—â— â†– ì´ í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ë ˆì´ì•„ì›ƒ Effectì™€ì˜ ì°¨ì´ì ì„ êµ¬ë¶„í•  ìˆ˜ ìˆì–´ ì¤‘ìš”í•©ë‹ˆë‹¤.
    // â—â— PassiveStaticEffectëŠ” ë¬´ì—‡ì¼ê¹Œìš”? ì´ ê²ƒì€ ë‹¤ë¥¸ ì—í”¼ì†Œë“œì—ì„œ ë‹¤ë£° ê°€ì¹˜ê°€ ìˆì„ê±° ê°™ìŠµë‹ˆë‹¤.
    HookPassive,
    create,
    deps,
  );
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps): void {
  const hook = mountWorkInProgressHook();
  // â—â— â†— ìƒˆë¡œìš´ í›…ì„ ë§Œë“­ë‹ˆë‹¤.
  const nextDeps = deps === undefined ? null : deps;
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(
  // â—â—               â†— pushEffect()ëŠ” Effect ê°ì²´ë¥¼ ë§Œë“¤ê³ , ê·¸ê²ƒì„ í›…ì— ì„¤ì •í•©ë‹ˆë‹¤.
    HookHasEffect | hookFlags,
    // â—â— â†– ì´ í”Œë˜ê·¸ë„ ì¤‘ìš”í•œë°, ì´ê²ƒì€ ì´ ì´íŒ©íŠ¸ë¥¼ ìµœì´ˆ ë§ˆìš´íŠ¸ì—ì„œ ì‹¤í–‰í•´ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.
    create,
    undefined,
    nextDeps,
  );
}
```

```typescript
function pushEffect(tag, create, destroy, deps) {
  const effect: Effect = {
    tag,
    // â—â— â†– tagëŠ” ì¤‘ìš”í•œë°, ì´ Effectë¥¼ ì‹¤í–‰í•´ì•¼ í•˜ëŠ”ì§€ ì—¬ë¶€ë¥¼ í‘œì‹œí•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
    create,
    // â—â— ìš°ë¦¬ê°€ ì „ë‹¬í•œ ì½œë°± ì…ë‹ˆë‹¤
    destroy,
    // â—â— ì½œë°±ì—ì„œ ë°˜í™˜í•œ ì •ë¦¬ í•¨ìˆ˜ ì…ë‹ˆë‹¤.
    deps,
    // â—â— ìš°ë¦¬ê°€ ì „ë‹¬í•œ deps ë°°ì—´ì…ë‹ˆë‹¤.
    // Circular
    next: (null: any),
    // â—â— í•˜ë‚˜ì˜ ì»´í¬ë„ŒíŠ¸ì— ì—¬ëŸ¬ Effectê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ê±¸ ì²´ì¸ìœ¼ë¡œ ì—®ìŠµë‹ˆë‹¤.
  };
  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);
  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);
    // â—â— EffectëŠ” fiberì˜ updateQueueì— ì €ì¥ë©ë‹ˆë‹¤.
    // â—â— ì´ê²ƒì€ í›…ì˜ memoizedStateì™€ëŠ” ë‹¤ë¦…ë‹ˆë‹¤.
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect === null) {
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
```

ìµœì´ˆ ë§ˆìš´íŠ¸ì˜ ê²½ìš°, useEffect()ê°€ í•„ìš”í•œ í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•˜ì—¬ Effect ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. effect ê°ì²´ë“¤ì€ ë‹¤ë¥¸ íƒ€ì´ë°ì— ì²˜ë¦¬ë  ê²ƒì…ë‹ˆë‹¤.

## 2\. ë¦¬-ë Œë”ë§ì˜ `useEffect()`

```typescript
function updateEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null,
): void {
  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps): void {
  const hook = updateWorkInProgressHook();
  // â—â— â†— í˜„ì¬ í›…ì„ ê°€ì ¸ì˜µë‹ˆë‹¤
  const nextDeps = deps === undefined ? null : deps;
  let destroy = undefined;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    // â—â—                        â†— memoizedStateì˜ effect í›…ì´ Effect ê°ì²´ë¼ëŠ” ê²ƒì„ ê¸°ì–µí•˜ì„¸ìš”.
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
      // â—â— depsê°€ ë³€ê²½ë˜ì§€ ì•Šìœ¼ë©´, Effect ê°ì²´ë¥¼ ë‹¤ì‹œ ìƒì„±í•˜ëŠ” ê²ƒë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤
      // â—â— ì—¬ê¸°ì„œ ë‹¤ì‹œ ìƒì„±í•´ì•¼ í•˜ëŠ” ì´ìœ ëŠ” ì•„ë§ˆë„ ë‹¨ìˆœíˆ updateQueueë¥¼ ë‹¤ì‹œ ìƒì„±í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì¼ê²ë‹ˆë‹¤.
      // â—â— ê·¸ë¦¬ê³  ìš°ë¦¬ëŠ” ì—…ë°ì´íŠ¸ ëœ create()í•¨ìˆ˜ë¥¼ ê°€ì ¸ì˜¬ í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.
      // â—â— ì—¬ê¸°ì„œëŠ” ì´ì „ destory() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê³  ìˆìŒë„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(
    HookHasEffect | hookFlags,
    // â—â— â†– ë§Œì•½ depsê°€ ë°”ë€Œë©´, HookHasEffect ëŠ” ì´ Effectë¥¼ ì‹¤í–‰ í•´ì•¼í•¨ì„ ë‚˜íƒ€ë‚´ëŠ” í‘œì‹œì…ë‹ˆë‹¤.
    create,
    destroy,
    nextDeps,
  );
}
```

ìš°ë¦¬ëŠ” í˜¼ë€ìŠ¤ëŸ¬ìš´ deps ë°°ì—´ì´ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ ì•Œ ìˆ˜ ìˆì—‡ìŠµë‹ˆë‹¤. ë¦¬-ë Œë”ë§í•  ë•ŒëŠ” ì–´ë–¤ ê²½ìš°ì—ëŠ” Effect ê°ì²´ë¥¼ ë‹¤ì‹œ ìƒì„±í•˜ì§€ë§Œ, depsê°€ ë³€ê²½ë˜ë©´ ìƒì„±ëœ Effectê°€ ì´ì „ ì •ë¦¬(`destory()`) í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹¤í–‰ë˜ë„ë¡ í‘œì‹œë©ë‹ˆë‹¤.

## 3\. EffectëŠ” ì–¸ì œ, ì–´ë–»ê²Œ ì‹¤í–‰ë˜ê³  ì •ë¦¬ë˜ë‚˜ìš”?

ìœ„ì—ì„œ ìš°ë¦¬ëŠ” `useEffect()`ê°€ Fiber Nodeì— ì¶”ê°€ ë°ì´í„° êµ¬ì¡°ë¥¼ ìƒì„±í•  ë¿ì´ë¼ëŠ” ê²ƒì„ ì•Œì•˜ìŠµë‹ˆë‹¤. ì´ì œ ì´ëŸ¬í•œ Effect ê°ì²´ê°€ ì–´ë–»ê²Œ ì²˜ë¦¬ë˜ëŠ”ì§€ ì•Œì•„ë³¼ í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.

### 3.1 íŒ¨ì‹œë¸Œ Effectì— ëŒ€í•œ flushingì€ `commitRoot()`ë‚´ì—ì„œ íŠ¸ë¦¬ê±° ë©ë‹ˆë‹¤.

ë‘ ê°œì˜ Fiber Tree(ì¡°ì •)ë¥¼ ë¹„êµí•˜ì—¬ ì„œë¡œ ë‹¤ë¥¸ ê²°ê³¼ë¥¼ ì–»ì€ í›„ "Commit" ë‹¨ê³„ì—ì„œ í˜¸ìŠ¤íŠ¸ DOMì— ë³€ê²½ ì‚¬í•­ì„ ë°˜ì˜í•©ë‹ˆë‹¤. íŒ¨ì‹œë¸Œ Effectì˜ ì˜ flushë¥¼ ì‹œì‘í•œ ì½”ë“œë¥¼ ì‰½ê²Œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```typescript
function commitRootImpl(
  root: FiberRoot,
  recoverableErrors: null | Array<CapturedValue<mixed>>,
  transitions: Array<Transition> | null,
  renderPriorityLevel: EventPriority,
) {
  // If there are pending passive effects, schedule a callback to process them.
  // Do this as early as possible, so it is queued before anything else that
  // might get scheduled in the commit phase. (See #16714.)
  // TODO: Delete all other places that schedule the passive effect callback
  // They're redundant.
  if (
    (finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||
    (finishedWork.flags & PassiveMask) !== NoFlags
  ) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      pendingPassiveEffectsRemainingLanes = remainingLanes;
      // workInProgressTransitions might be overwritten, so we want
      // to store it in pendingPassiveTransitions until they get processed
      // We need to pass this through as an argument to commitRoot
      // because workInProgressTransitions might have changed between
      // the previous render and commit if we throttle the commit
      // with setTimeout
      pendingPassiveTransitions = transitions;
      scheduleCallback(NormalSchedulerPriority, () => {
        flushPassiveEffects();
        // This render triggered passive effects: release the root cache pool
        // *after* passive effects fire to avoid freeing a cache pool that may
        // be referenced by a node in the tree (HostRoot, Cache boundary etc)
        return null;
      });
      // â—â— ì—¬ê¸°ì„œ useEffect()ì— ì˜í•´ ìƒê²¨ë‚œ íŒ¨ì‹œë“œ Effectë¥¼ í”ŒëŸ¬ì‹œ í•©ë‹ˆë‹¤.
      // â—â— ì´ë ‡ê²Œ í•˜ë©´ ë‹¹ì¥ì´ ì•„ë‹Œ ë‹¤ìŒ í‹±(tick)ì— í”ŒëŸ¬ì‹±ì´ ì˜ˆì•½ë©ë‹ˆë‹¤.
      // â—â— ì¢€ ë” ìì„¸í•œ ì •ë³´ëŠ” EP20ì˜ ë¦¬ì•¡íŠ¸ ìŠ¤ì¼€ì¥´ëŸ¬ëŠ” ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ê°€ë¥¼ ì°¸ê³ í•˜ì„¸ìš”
    }
  }
  ...
}
```

> [EP20 - ë¦¬ì•¡íŠ¸ ìŠ¤ì¼€ì¥´ëŸ¬ëŠ” ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ê°€? scheduleCallback() ë¶ë§ˆí¬](https://jser.dev/react/2022/03/16/how-react-scheduler-works/#41-schedulecallback---scheduler-schedules-tasks-by-exipriationtime)

### 3.2 `flushPassiveEffects()`

```typescript
function flushPassiveEffectsImpl() {
  if (rootWithPendingPassiveEffects === null) {
    return false;
  }
  // Cache and clear the transitions flag
  const transitions = pendingPassiveTransitions;
  pendingPassiveTransitions = null;
  const root = rootWithPendingPassiveEffects;
  const lanes = pendingPassiveEffectsLanes;
  rootWithPendingPassiveEffects = null;
  // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.
  // Figure out why and fix it. It's not causing any known issues (probably
  // because it's only used for profiling), but it's a refactor hazard.
  pendingPassiveEffectsLanes = NoLanes;
  const prevExecutionContext = executionContext;
  executionContext |= CommitContext;
  commitPassiveUnmountEffects(root.current);
  commitPassiveMountEffects(root, root.current, lanes, transitions);
  // â—â—â†— ì—¬ê¸°ì„œ ìš°ë¦¬ëŠ” ì½œë°±ì´ ì‹¤í–‰ë˜ì§€ ì „ì— Effect ì •ë¦¬ê°€ ë¨¼ì € ì‹¤í–‰ë˜ëŠ” ê²ƒì„ ëª…í™•í•˜ê²Œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  ...
}
```

### 3.3 `commitPassiveUnmountEffects()`

```typescript
export function commitPassiveUnmountEffects(finishedWork: Fiber): void {
  setCurrentDebugFiberInDEV(finishedWork);
  commitPassiveUnmountOnFiber(finishedWork); // â—â— commitPassiveUnmountOnFiber
  resetCurrentDebugFiberInDEV();
}
function commitPassiveUnmountOnFiber(finishedWork: Fiber): void {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      // â—â— â†— ìš°ë¦¬ëŠ” ì—¬ê¸°ì„œ ìì‹ë“¤ì˜ effectsë“¤ì´ ë¨¼ì € ì •ë¦¬ë˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
      if (finishedWork.flags & Passive) {
        commitHookPassiveUnmountEffects( // â—â— commitHookPassiveUnmountEffects
          finishedWork,
          finishedWork.return,
          HookPassive | HookHasEffect,
          // â—â—         â†— ì´ í”Œë˜ê·¸(HookHasEffect)ëŠ” depsê°€ ë³€ê²½ë˜ì§€ ì•Šì•˜ì„ ë•Œ í›…ì´ ì‹¤í–‰ë˜ì§€ ì•ŠëŠ” ê²ƒì„ ë³´ì¥í•©ë‹ˆë‹¤
        );
      }
      break;
    }
    ...
  }
}
function commitHookPassiveUnmountEffects(
  finishedWork: Fiber,
  nearestMountedAncestor: null | Fiber,
  hookFlags: HookFlags,
) {
  if (shouldProfile(finishedWork)) {
    startPassiveEffectTimer();
    commitHookEffectListUnmount( // â—â— commitHookEffectListUnmount
      hookFlags,
      finishedWork,
      nearestMountedAncestor,
    );
    recordPassiveEffectDuration(finishedWork);
  } else {
    commitHookEffectListUnmount( // â—â— commitHookEffectListUnmount
      hookFlags,
      finishedWork,
      nearestMountedAncestor,
    );
  }
}
function commitHookEffectListUnmount(
  flags: HookFlags,
  finishedWork: Fiber,
  nearestMountedAncestor: Fiber | null,
) {
  const updateQueue: FunctionComponentUpdateQueue | null =
    (finishedWork.updateQueue: any);
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag & flags) === flags) { // â—â— (effect.tag & flags) === flags
        // Unmount
        const inst = effect.inst;
        const destroy = inst.destroy;
        if (destroy !== undefined) {
          inst.destroy = undefined;
          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
        }
      }
      effect = effect.next;
    } while (effect !== firstEffect);
    // â—â— ì—¬ê¸°ì„œëŠ” updateQueueì˜ ëª¨ë“  effectë¥¼ ë‹¨ìˆœíˆ ë£¨í”„ ëŒê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤
    // â—â— ê·¸ëŸ¬ë©´ì„œ í”Œë˜ê·¸ë¥¼ í†µí•´ í•„ìš”í•œ í•­ëª©ë“¤ì„ í•„í„°ë§ í•©ë‹ˆë‹¤.
  }
}
function safelyCallDestroy(
  current: Fiber,
  nearestMountedAncestor: Fiber | null,
  destroy: () => void,
) {
  try {
    destroy();
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
```

### 3.4 `commitPassiveMountEffects()`

`commitPassiveMountEffects()`ëŠ” ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤.

```typescript
export function commitPassiveMountEffects(
  root: FiberRoot,
  finishedWork: Fiber,
  committedLanes: Lanes,
  committedTransitions: Array<Transition> | null,
): void {
  setCurrentDebugFiberInDEV(finishedWork);
  commitPassiveMountOnFiber( // â—â— commitPassiveMountOnFiber
    root,
    finishedWork,
    committedLanes,
    committedTransitions,
  );
  resetCurrentDebugFiberInDEV();
}
function commitPassiveMountOnFiber(
  finishedRoot: FiberRoot,
  finishedWork: Fiber,
  committedLanes: Lanes,
  committedTransitions: Array<Transition> | null,
): void {
  // When updating this function, also update reconnectPassiveEffects, which does
  // most of the same things when an offscreen tree goes from hidden -> visible,
  // or when toggling effects inside a hidden tree.
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent: {
      recursivelyTraversePassiveMountEffects(
      // â—â— â†– ìš°ë¦¬ëŠ” ì—¬ê¸°ì„œ ìì‹ë“¤ì˜ effectsë“¤ì´ ë¨¼ì € ì‹¤í–‰ë˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
      );
      if (flags & Passive) {
        commitHookPassiveMountEffects( // â—â— commitHookPassiveMountEffects
          finishedWork,
          HookPassive | HookHasEffect,
          // â—â—        â†— ì´ í”Œë˜ê·¸(HookHasEffect)ëŠ” depsê°€ ë³€ê²½ë˜ì§€ ì•Šì•˜ì„ ë•Œ í›…ì´ ì‹¤í–‰ë˜ì§€ ì•ŠëŠ” ê²ƒì„ ë³´ì¥í•©ë‹ˆë‹¤

        );
      }
      break;
    }
    ...
  }
}
function commitHookPassiveMountEffects(
  finishedWork: Fiber,
  hookFlags: HookFlags,
) {
  if (shouldProfile(finishedWork)) {
    startPassiveEffectTimer();
    try {
      commitHookEffectListMount(hookFlags, finishedWork); // â—â— commitHookEffectListMount
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    recordPassiveEffectDuration(finishedWork);
  } else {
    try {
      commitHookEffectListMount(hookFlags, finishedWork); // â—â— commitHookEffectListMount
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function commitHookEffectListMount(flags: HookFlags, finishedWork: Fiber) {
  const updateQueue: FunctionComponentUpdateQueue | null =
    (finishedWork.updateQueue: any);
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag & flags) === flags) {
        // Mount
        const create = effect.create;
        const inst = effect.inst;
        const destroy = create();
callback is run here!

        inst.destroy = destroy;
      }
      effect = effect.next;
    } while (effect !== firstEffect);
    // â—â— ë‹¤ì‹œ, í•„ìš”í•œ Effectë“¤ì„ í•„í„°ë§í•˜ê³  ë‹¤ìŒì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
  }
}
```

## 4\. ìš”ì•½

ì†ŒìŠ¤ ì½”ë“œë¥¼ ì‚´í´ë³¸ ê²°ê³¼, `useEffect()`ì˜ ë‚´ë¶€ êµ¬ì¡°ëŠ” ë§¤ìš° ê°„ë‹¨í•˜ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

1. `useEffect()` ëŠ” Fiberì— ì €ì¥ë˜ì–´ ìˆëŠ” Effect ê°ì²´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    
    * Effect ëŠ” ì‹¤í–‰ì´ í•„ìš”í•œì§€ ì—¬ë¶€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” `tag` ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
        
    * Effect ëŠ” ì²«ë²ˆì§¸ ì¸ìˆ˜ë¡œ ì „ë‹¬ë˜ëŠ” `create()` í•¨ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.
        
    * Effect `create()`ì˜ ì •ë¦¬ì¸ `destroy()`ê°€ ìˆê³ , ì´ê²ƒì€ `create()`ê°€ ì‹¤í–‰ë  ë•Œë§Œ ì„¤ì •ë©ë‹ˆë‹¤.
        
2. `useEffect()` ëŠ” ë§¤ë²ˆ ìƒˆë¡œìš´ Effect ê°ì²´ë“¤ì„ ë§Œë“¤ì–´ëƒ…ë‹ˆë‹¤, í•˜ì§€ë§Œ ì´ê²ƒë“¤ì€ ë§Œì•½ deps ë°°ì—´ì´ ë³€ê²½ë˜ë©´ ë‹¤ë¥¸ `tag`ë¥¼ ì„¤ì •í•˜ê²Œ ë©ë‹ˆë‹¤.
    
3. í˜¸ìŠ¤íŠ¸ DOMì— ì—…ë°ì´íŠ¸ë¥¼ ì»¤ë°‹í•  ë•Œ, ë‹¤ìŒ í‹±(tick)ì˜ ì‘ì—…ì€ `tag`ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ëª¨ë“  Effectë¥¼ ë‹¤ì‹œ ì‹¤í–‰ í•˜ë„ë¡ ì˜ˆì•½ë©ë‹ˆë‹¤.
    
    * í•˜ìœ„ ì»´í¬ë„ŒíŠ¸ì˜ Effectê°€ ë¨¼ì € ì²˜ë¦¬ ë©ë‹ˆë‹¤.
        
    * ì •ë¦¬ê°€ ë¨¼ì € ì‹¤í–‰ë©ë‹ˆë‹¤.
        

## 5\. í€´ì¦ˆ ì±Œë¦°ì§€

ì´ì œ ì˜¤ëŠ˜ ë°°ìš´ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ [BFE.dev](http://BFE.dev)ì˜ React í€´ì¦ˆë¥¼ í’€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* í€´ì¦ˆ ë§í¬: [https://bigfrontend.dev/react-quiz/useeffect-iii](https://bigfrontend.dev/react-quiz/useeffect-iii)
    

ì›ë³¸ ê¸€ ì‘ì„±ì¼: 2023-07-08